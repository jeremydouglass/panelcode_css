/*

# MISC

1. consoles default open
2. console show/hide all web button
3. check for console initial show/hide override gallery option

## tranformer

simplify: _
sort: _

## filter

<2
>3
=5
is 1_2_3

##  Labeling and autolabeling

layout	
layout	label
layout			img
layout	label	img
layout			img	ilabel
layout	label	img	ilabel

Autolabeling of layouts or images can be set on the spread or gallery options.

Simply assign label or ilabel.

Labels are attached 

{@ label = $copy }
{@ label = $move } 
{@ label = $img  } # page01, page02, etc.
{@ label = $1    } # 1, 2, 3...
{@ label = $01   } # 1, 2, 3...
{@ label = $174  } # 174, 175, 176...

ilabel =  


set label on spread or gallery

label=#
label=#

autolabel=1
autolabel=174
autolabel=img
iautolabel=1

label='1'
label='174'
label='img'

autolabel copies the image filename to the layout label


iautolabel

image	layout				
image	layout				autolabel
image	layout				autolabel
image(ibefore - labeled)	layout				autolabel

image(labeled)		layout(labeled)	autolabel


# Pygments syntax highlighter

Panelcode is unlike many other syntax highlighted languages:

-  Operators are primarily delimiters (like punctuation) and they structure the language.
-  Some integers are entities (panels). Others are arguments.
-  Attributes such as c2 r2 are a key-value pairs
-  There are lots of attributes -- some of them are built-in / have special processing, such as bleed or img=, others no.
-  Strings often contain ids -- page numbers, labels, or image filenames.

Choose selected tokens as semantic, map them to colors:

-  http://pygments.org/docs/tokens/
-  http://ethanschoonover.com/solarized

## obvious

-  **Operator**
   Matches @ ; | _ , + - and = :
-  **Punctuation**
   Matches {: } ( )
-  **Comment.Single**
   Matches // or ## to the end of the line
-  **Text**
   For matching e.g. whitespace.
-  **Number**
   Matches PanelIdentifiers that begin with a number
-  **Name.Attribute**
   Matches generic dot attributes or opt attributes.
-  **String**
   Matches '...' or "..." in attributes

# probably

Number
Token type for any number literal.

Number.Integer
Token type for integer literals (e.g. 42).

Name.Builtin
Builtin names; names that are available in the global namespace.

Literal
For any literal (if not further defined).

String
For any string literal.

## Someday:

Comment.Single
Token type for comments that end at the end of a line (e.g. # foo).

#### num

Name.Label
Token type for label names (e.g. in languages that support goto).

#### path

Name.Namespace
Token type for namespaces. (e.g. import paths in Java/Python), names following the module/namespace keyword in other languages.

Comment.Multiline
Token type for multiline comments.

#### root opts

Comment.Hashbang
Token type for hashbang comments (i.e. first lines of files that start with
#!).

#### multiple string types

String.Double
Double quoted strings.

String.Single
Token type for single quoted strings.

String.Other
Token type for any other strings (for example %q{foo} string constructs in Ruby).

#### Maybe:

String.Affix
Token type for affixes that further specify the type of the string they’re attached to (e.g. the prefixes r and u8 in r"foo" and u8"foo").

Name
For any name (variable names, function names, classes).

Keyword
	For any kind of keyword (especially if it doesn’t match any of the subtypes of course).

Keyword.Reserved
	For reserved keywords.

Name.Other
Other names. Normally unused.

Name.Tag
Tag names (in HTML/XML markup or configuration files).

Name.Decorator
Token type for decorators. Decorators are syntactic elements in the Python language. Similar syntax elements exist in C# and Java.

Name.Function
Token type for function names.

Name.Function.Magic
same as Name.Function but for special function names that have an implicit use in a language (e.g. __init__ method in Python).

String.Char
Token type for single characters (e.g. Java, C).


# Parsing flow in Panelcode
2018-01-02

-  Railroad diagrams generated by: http://www.bottlecaps.de/rr/ui
-  W3C token railroad diagrams: https://www.w3.org/TR/css-syntax-3/#token-diagrams
-  JSON diagrams: https://www.json.org/

Panelcode syntax combines a few main structures:

1. **Layouts**: a description language for abstract page composition based on **rowgroups** and **panel** identifiers. Details of the design are primarily influenced by the historical evolution of HTML Tables and the affordances of CCS3 Grid rendering.
2. *Heirarchies* for organizing layouts: **spreads** for sequences of contiguous layouts, and **galleries** for collections of spreads and layouts.
3. **Attributes** which can be attached either directly to panel identifiers or to rowgroups, layouts, spreads, or galleries via **options**. Attributes are influenced by the constrains of CSS and the design of Maraku and kramdown IALS.


## Layout design



## Heirarchy design: layouts, spreads and galleries.

Panelcode can be described as a series of nested containers joined by delimiters: One or more Galleries ('@') containing Spreads ('|') containing Layouts (';'). Layouts themselves contain one or more PanelGroups ('_') consisting of Panels ('+'|','). Because all delimiters are optional, these are both valid Panelcode strings:

-  1
-  1 @ 2 ; 3 | 4_5 ; 6_1+2,3 @ 1

#### The delimited list form

This form is based on the basic form of the delimited list, which requires delimiters between items, but not before or after.

*/

	char-seq
	    ::= empty | char ( ',' char )*

/*

At a basic level, these delimiters are a method of grouping individual Panelcode Layouts and grouping them into spreads or galleries. 

*/

	pc-root-layouts-full
	    ::= layout ( layout-delim layout)* ( spread-delim layout ( layout-delim layout)* )* ( gallery-delim layout ( layout-delim layout)* ( spread-delim layout ( layout-delim layout)* )* )*

	pc-root-layouts-concise
	    ::= L ( '|' L)* ( ';' L ( '|' L)* )* ( '@' L ( '|' L)* ( ';' L ( '|' L)* )* )*

/*




## Attribute design

Attributes either modify a panel identifier or appear in an options group.

A panel identifier may be:

1. a counter (1, 2, 3...)
2. a counter followed by one or more panel attributes
3. one or more panel attributes (with no counter)

These are all examples of valid panel identifiers:

	2
	2c3
	2.c3
	1.c3.r2.bleed-a.red
	c3.r2

Here is EBNF for a panel identifier railroad diagram:

    PanelIdentifier
        ::= (Digit)*
            ('.')?
            (Attribute)
            (('.')(Attribute))*

Panelcode attributes can only contain alphanumeric characters [a-zA-Z0-9] plus the underscore (_) and the hyphen (-). Attributes must start with an alphabetic character [a-zA-Z].

    Attribute
         ::= alpha (alphanum|'_')?

Panelcode is designed to be embedded in web documents and other markups and data formats, so the syntax is designed to maximize compatability with web rendering (CSS identifiers) and minimize collisions with common container web formats.

All Panelcode attributes are valid CSS identifiers.[^css-ident] In practice this means that Panelcode attributes may be used like tags. Tags may be invented on-the-fly, with special rendering behaviors added later. Any attribute may be passed through the Panelcode parser and the HTML renderer as a class and styled directly using a CSS stylesheet. Panelcode attributes are also compatible with the CSS naming methodologies and conventions such as SMACSS or Block, Element, Modifier (BEM), which e.g. uses underscores and dashes as follows: `block-name__elem-name_mod-name_mod-val`.

Attribute design is primarily of interest for annotation, designing CSS stylesheets to extend panelcode display, and handling of built-in variable types like c, r, w, b, x, u, img=, ishow, etc.

Attributes in dot notation look like this:

    ; 1.u7
    | 7{w3}
    | 2 _ 3 _ 2
    | 2 _ (c9 + c7 + c4) _ (c2 + c3)
    | c10.r5.b-ub
    , c10.r5.b-u
    , c9.r3.b-b + c7.r3 + c4.r3
    , c8.r4.b:d + c12.r4.b-d
      {: ilabel='200' img='images/200.png' }

Here is a partial list of reserved attributes. It might be worth separating out a core and adding others as extensions.

Reserved:

	c	colspan
	r	rowspan
	b	bleed	bleed*
		label
	w	width
		rtl

...some ways that these might be written(?):

	c2	cols2 colspan2
	c-2	cols-2	colspan-2


internal:

	p	panel
	panelgroup
	layout
	spread
	gallery

media:

	default
	thumb
	small
	mini
	micro
	micro2
	micro3

transform:

	circle
	rot*
	rot-up*
	rot-down*
	scale*
	skew*
	skew-fwd*
	skew-back*
	iso	?
	tx*
	ty*

blanks;

	x	?	0
	z	?
	u	?

images:

	i	img	image
	iover
	ilabel

	ishow
	ihide

colors:

	black
	white
	red
	green
	yellow
	magenta
	cyan
	gray0-9
	grayA-F
	texture1-4

shorthands:

	v	vertical


...

##### more brainstorming on attributes

root
	{} an options block
	+,_|@ delimiter
	()
	1
	a-z
	.

	panel
	dotopt
	bareopt

	{} an options block	pop
	+,_|@ delimiter      pop

	1			10
	1z			10z
	1.z		10.z
	1c2		1c2
	1.c2		10.c2
	1c2.r2	10c2.r2
	1.c2.r2	10.c2.r2
	1bleed	10bleed
	1.bleed	10.bleed
	1.b-a		10.b-a

an option can consist of

b--a

b-a-c

bleed-a

bleed-a2

b-a2

a letter followed by zero or more letters or dashes
	optionally followed by one or more numbers

[a-zA-Z][]




#### Attaching options

One of the primary purposes of these contexts is to allow heirarchical grouping for organization and display. Layouts may be grouped as physically or logically contiguous (spreads), as with a two-page spreads, and any groups of layouts and/or spreads may be organized into collections (galleries) -- for example, organizing a series of pages into singles and two-page spreads, then grouping then into chapter galleries.

Galleries and spreads also serve as a way of organizing metadata through options. Any level of organization can attach options, and options may cascade and be overridden at lower levels. One might mark a collection of layouts at the gallery level as black-and-white, but then annotating a two-page spread as color, for example -- or mark a gallery of pages as right-to-left reading order, but include one spread in from a translation, marked left-to-right.

*/

	pc-root-layouts-opts-full
	    ::= layout ( layout-opts? layout-delim layout)* ( spread-opts? spread-delim layout ( layout-opts? layout-delim layout)* )* ( gallery-opts? gallery-delim layout ( layout-opts? layout-delim layout)* ( spread-opts? spread-delim layout ( layout-opts? layout-delim layout)* )* )* root-opts?

	pc-root-layouts-opts-concise
	    ::= L ( LO? '|' L)* ( SO? ';' L ( LO? '|' L)* )* ( GO? '@' L ( LO? '|' L)* ( SO? ';' L ( LO? '|' L)* )* )* RO?


/*

## Putting it all together

*/

    pc-levels-root-full
        ::= gallery gallery-opts? ( gallery-delim gallery gallery-opts? )* root-opts?
    gallery ::= spread spread-opts? ( spread-delim spread spread-opts? )*
    spread  ::= layout layout-opts? ( layout-delim layout layout-opts? )*
    layout  ::= pgroup pgroup-opts? ( pgroup-delim pgroup pgroup-opts? )*
    pgroup  ::= panel ( ('+'|',') panel )*
    panel   ::= number* '.'? (attrib ( '.' attrib )*)?
    root-opts     ::= '{!' attrib* '}'
    gallery-opts  ::= '{' gallery-delim attrib* '}'
    spread-opts   ::= '{' spread-delim  attrib* '}'
    layout-opts   ::= '{' layout-delim  attrib* '}'
    pgroup-opts   ::= '{' pgroup-delim  attrib* '}'
    panel-opts    ::= '{' panel-delim   attrib* '}'
    gallery-delim ::= '@'
    spread-delim  ::= ';'
    layout-delim  ::= '|'
    pgroup-delim  ::= '_'
    panel-delim   ::= '+'
    attrib        ::= Attribute


    pc-levels-root-newdelim
        ::= (root-delim opts)? gallery? ( gallery-delim opts? gallery )*
    gallery ::= spread ( spread-delim opts? spread )*
    spread  ::= layout ( layout-delim opts? layout )*
    layout  ::= pgroup ( pgroup-delim opts? pgroup )*
    pgroup  ::= panel ( ('+'|',') panel )*
    panel   ::= number* '.'? (attrib ( '.' attrib )*)?
    root-opts     ::= '{!' attrib* '}'
    gallery-opts  ::= '{' gallery-delim attrib* '}'
    spread-opts   ::= '{' spread-delim  attrib* '}'
    layout-opts   ::= '{' layout-delim  attrib* '}'
    pgroup-opts   ::= '{' pgroup-delim  attrib* '}'
    panel-opts    ::= '{' panel-delim   attrib* '}'
    root-delim    ::= '!'
    gallery-delim ::= '@'
    spread-delim  ::= ';'
    layout-delim  ::= '|'
    pgroup-delim  ::= '_'
    panel-delim   ::= '+'
    opts          ::= '{' '_' attrib* '}'
    attrib        ::= Attribute


/* More stuff */

    MarkdownFencedPanelcode
             ::= ( Markdown | '```panelcode' Panelcode '```' | '~~~panelcode' Panelcode '~~~' )+
    Panelcode
             ::= Gallery ('@' Gallery)* ('{!' Attribute* '}')?
    Gallery
             ::= Spread ('|' Spread)* ('{@' Attribute* '}')?
    Spread
             ::= Layout (';' Layout)* ('{|' Attribute* '}')?
    Layout
             ::= Panelgroup ('_' Panelgroup)* ('{;' Attribute* '}')?
    Panelgroup
             ::= '('? PanelIdentifier ( ('+' | ',') PanelIdentifier )* ')'? ('{_' Attribute* '}')?
    PanelIdentifier
             ::= number* '.'? Attribute ( '.' Attribute )* ('{+' Attribute* '}')?
    OptsP
             ::= '{+' Attribute* '}'
    Attribute
             ::= Tag (':' Value)?
                | SimpleKeyVal
    Tag
             ::=  ('-')?(letter|'_')(letter|number|'_'|'-')*
    Tag-ident-regex
             ::=  ('-')?('a-z A-Z _')('a-z A-Z 0-9 _ -')*
    Value
             ::= number|Tag|string
    SimpleKeyVal
             ::=  letter+ number
    letter
             ::= [a-zA-Z]
    number
             ::= [0-9]+
    string   ::= "'" "not ' or newline"* "'"
               | '"' 'not " or newline'* '"'
    Comment
             ::=  ('//'|'#') 'not a newline'* 'newline or EOF'


## Embedded Panelcode: Avoiding Collisions

Panelcode does not use characters the most common characters that must be escaped in HTML ('<' '>' '&'). It also avoids the delimiters that are common to contemporary web templating languages such as PHP (`<?`), ASP or Rails/ERB (`<%`), and Moustache, Jinja2, or Jekyll/Liquid (`{%`, `{{`). However, there are inevitably some collisions that need to be dealt with when interoperating with different languages and formats.

#### Collisions and HTML

Panelcode strings may be written into HTML pages directly without escaping, and will display on the webpage as valid Panelcode. As is typical for HTML, whitespace (such as linebreaks, indenting, etc.) will be lost. Whitespace is not semantic in Panelcode, but it may aid readability, so a solution is to embed panelcode in a `<pre></pre>` or `<pre><code></code></pre>` code block.

#### Collisions and Markdown

Panelcode supports two forms of in-line comments:

1.  double-slash (`//`) comments, common in C++, Go, Java, JavaScript, Scala, SASS, et cetera.
2.  hash-style (`#`) comments, common in Unix shell script, Python, Perl, R, Ruby, et cetera.

Hash-style comments overlap with Markdown header formatting (e.g. #Heading1, ##Heading2) when the hash is the first character in the line -- however **no collisions occur** when Panelcode is placed within fenced code blocks in a Markdown document.

Options to use commented Panelcode outside a code block in Markdown:

1.  use //, not #
2.  do not put # at the beginning of the line - e.g. add a space
3.  pre-process the Panelcode before Markdown

Panelcode's use of `{:` `{::` `{:::` et cetera for options partially overlaps with the inline attribute lists (IALs) syntax of the Maruku and kramdown interpreters for Markdown (https://kramdown.gettalong.org/syntax.html#block-ials) (https://golem.ph.utexas.edu/~distler/maruku/proposal.html#using_tags), as well as with their extension syntax. However, **no collisions occur** when Panelcode is placed within fenced code blocks in a Markdown document.

Options to use inline Panelcode options with kramdown/Maruku:

1.  HTML-encode `{` as `&#123;`
2.  configure an alternate delimiter pair
3.  pre-process Panelcode before Markdown

#### Angular.js

A Panelcode `{:: options }` block resembles (but does not match or collide with) an Angular.js [expression with one-time binding](https://docs.angularjs.org/guide/expression#one-time-binding), e.g. `{{::myColor}}`

#### Collisions and JSON

Embedding Panelcode in JSON requires typical escaping: of double-quoted strings (`"`->`\"`), linebreaks (`\n`), and any JSON-reserved characters that occur within attribute strings.

#### CSV / TSV

Panelcode uses the `,` delimiter, which is also used in CSV (comma-separated value files. In addition, it allows single-quoted and double-quoted values, which may conflict with CSV processors that use quoted strings.

For flat text data files, a better choice is to embed Panelcode strings in an unquoted TSV (tab-separated value) file, as tabs have no special meaning in Panelcode.

#### YAML

Panelcode uses many characters that may need to be escaped in YAML formatting, including: @, |, ;, ,, {, :, }, #, =, and -. It also may make extensive use of whitespace formatting for readability, and 

In order to save Panelcode in YAML strings, rather than escaping all special characters and whitespace, instead use YAML literal block scalars

    pcode: |
        2 + r2.c2, 3
        @
        1
        | 2_2.red
        ; 3{: img='1.png' }

http://yaml.org/spec/1.2/spec.html#id2795688
http://yaml-multiline.info/


----------

[^css-ident]: 
  CSS2:
  >   In CSS, identifiers (including element names, classes, and IDs in  selectors) can contain only the characters [a-zA-Z0-9] and ISO 10646 characters U+00A0 and higher, plus the hyphen (-) and the underscore (_); they cannot start with a digit, two hyphens, or a hyphen followed by a digit.  
  CSS3:
  >   https://www.w3.org/TR/css-syntax-3/#ident-token-diagram


## MISC

This code is rendered directly to railroad diagrams through http://www.bottlecaps.de/rr/ui

	PanelIdentifier
	         ::= counter? '.'? Attribute ( '.' Attribute )*
	Attribute
	         ::= alpha (alphanum|'_')* ( '-' (alphanum|'_')+ )?
	alphanum
	         ::= [a-zA-Z0-9]
	alpha
	         ::= [a-zA-Z]
	counter
	         ::= [1-9][0-9]*

For reference, see the CSS3 railroad diagram for an ident token:

-  https://www.w3.org/TR/css-syntax-3/#ident-token-diagram

This is a simplified version of the CSS3 ident sans escaped characters and non-ASCII support:

	CSS3-ident
	    ::= ('-'?)('a-z A-Z 0-9'?)('a-z A-Z 0-9 _ -'*)

Panelcode attributes may parsed as a key value pair if they:

1. consist of only letters followed by only digits ([a-zA-Z]+)([0-9]+)
    -  c2
    -  myValue23
2. consist of only letters followed by a dash and 
    -  c-2
    -  color-red

https://www.w3.org/TR/css-syntax-3/#string-token-diagram



/*

# Addenda

When this series of simple substitutions is combined, the flow of parsing can appear daunting.

*/

    root-levels-combined
        ::= P
            ( ('+'|',') P )* PGO?
            ( '_' P ( ('+'|',') P )* PGO? )* LO?
            ( ';' L LO? )* SO?
            ( '|' P ( ('+'|',') P )* PGO?
              ( '_' P ( ('+'|',') P )* PGO? )* LO?
              ( ';' P ( ('+'|',') P )* PGO?
                ( '_' P ( ('+'|',') P )* PGO? )* LO?
              )* SO?
            )* GO?
            ( '@' P ( ('+'|',') P )* PGO?
              ( '_' P ( ('+'|',') P )* PGO? )* LO?
              ( ';' P ( ('+'|',') P )* PGO?
                ( '_' P ( ('+'|',') P )* PGO? )* LO?
              )* SO?
              ( '|' P ( ('+'|',') P )* PGO?
                ( '_' P ( ('+'|',') P )* PGO? )* LO?
                ( ';' P ( ('+'|',') P )* PGO?
                  ( '_' P ( ('+'|',') P )* PGO? )* LO?
                )* SO?
              )* GO?
            )* RO?

/*

Due to the optional natue of delimiters and the fact that they do not open or close, option blocks cannot be generic -- for example, this approach does not work because it is ambiguous which option in the heirarchy is being encountered.

*/

	root-levels-genericopts
	    ::= Gb O? ( '@' Gb O? )* O?
	Gb  ::= Sb O? ( '|' Sb O? )*
	Sb  ::= Lb O? ( ';' Lb O? )*
	Lb  ::= PGb O? ( '_' PGb O? )*
	PGb ::= Pb ( ('+'|',') Pb )*
	Pb  ::= number* '.'? att ( '.' att )* O?
	
	root-levels-genericopts-combined
	    ::= P ( ('+'|',') P )* O? ( '_' P ( ('+'|',') P )* O? )* O? ( ';' L O? )* O? ( '|' P ( ('+'|',') P )* O? ( '_' P ( ('+'|',') P )* O? )* O? ( ';' P ( ('+'|',') P )* O? ( '_' P ( ('+'|',') P )* O? )* O? )* O? )* O? ( '@' P ( ('+'|',') P )* O? ( '_' P ( ('+'|',') P )* O? )* O? ( ';' P ( ('+'|',') P )* O? ( '_' P ( ('+'|',') P )* O? )* O? )* O? ( '|' P ( ('+'|',') P )* O? ( '_' P ( ('+'|',') P )* O? )* O? ( ';' P ( ('+'|',') P )* O? ( '_' P ( ('+'|',') P )* O? )* O? )* O? )* O? )* O?

/*

# MISC RAILROAD PASTEBINS

    pc-levels-root-full
        ::= gallery gallery-opts? ( gallery-delim gallery gallery-opts? )* root-opts?
    gallery ::= spread  spread-opts? ( spread-delim spread spread-opts? )*
    spread  ::= layout  layout-opts? ( layout-delim layout layout-opts? )*
    layout  ::= pgroup  pgroup-opts? ( pgroup-delim pgroup pgroup-opts? )*
    pgroup  ::= panel ( ('+'|',') panel )*
    panel   ::= number* '.'? attrib ( '.' attrib )*
    gallery-delim ::= '@'
    spread-delim  ::= ';'
    layout-delim  ::= '|'
    pgroup-delim  ::= '_'
    root-opts     ::= '{!' attrib* '}'
    gallery-opts  ::= '{@' attrib* '}'
    spread-opts   ::= '{;' attrib* '}'
    layout-opts   ::= '{|' attrib* '}'
    pgroup-opts   ::= '{_' attrib* '}'
    panel-opts    ::= '{+' attrib* '}'


    pc-levels-root-full
        ::= gallery gallery-opts? ( gallery-delim gallery gallery-opts? )* root-opts?
    gallery ::= spread spread-opts? ( spread-delim spread spread-opts? )*
    spread  ::= layout layout-opts? ( layout-delim layout layout-opts? )*
    layout  ::= pgroup pgroup-opts? ( pgroup-delim pgroup pgroup-opts? )*
    pgroup  ::= panel ( ('+'|',') panel )*
    panel   ::= number* '.'? (attrib ( '.' attrib )*)?
    root-opts     ::= '{!' attrib* '}'
    gallery-opts  ::= '{' gallery-delim attrib* '}'
    spread-opts   ::= '{' spread-delim  attrib* '}'
    layout-opts   ::= '{' layout-delim  attrib* '}'
    pgroup-opts   ::= '{' pgroup-delim  attrib* '}'
    panel-opts    ::= '{' panel-delim   attrib* '}'
    gallery-delim ::= '@'
    spread-delim  ::= ';'
    layout-delim  ::= '|'
    pgroup-delim  ::= '_'
    panel-delim   ::= '+'


    pc-levels-root-full
        ::= gallery gallery-opts? ( gallery-delim gallery gallery-opts? )* root-opts?
    gallery ::= spread  spread-opts? ( spread-delim spread spread-opts? )*
    spread  ::= layout  layout-opts? ( layout-delim layout layout-opts? )*
    layout  ::= pgroup  pgroup-opts? ( pgroup-delim pgroup pgroup-opts? )*
    pgroup  ::= panel ( ('+'|',') panel )*
    pgroup-full ::= number* '.'? attrib ( '.' attrib )* ( ('+'|',') number* '.'? attrib ( '.' attrib )* )*
    panel   ::= number* '.'? attrib ( '.' attrib )*
    gallery-delim ::= '@'
    spread-delim  ::= ';'
    layout-delim  ::= '|'
    pgroup-delim  ::= '_'
    root-opts     ::= '{!' attrib* '}'
    gallery-opts  ::= '{@' attrib* '}'
    spread-opts   ::= '{;' attrib* '}'
    layout-opts   ::= '{|' attrib* '}'
    pgroup-opts   ::= '{_' attrib* '}'
    panel-opts    ::= '{+' attrib* '}'
    attrib        ::= Attribute





    pc-levels-root-full
        ::= gallery gallery-opts? ( gallery-delim gallery gallery-opts? )* root-opts?
    gallery ::= spread  spread-opts? ( spread-delim spread spread-opts? )*
    spread  ::= layout  layout-opts? ( layout-delim layout layout-opts? )*
    layout  ::= pgroup  pgroup-opts? ( pgroup-delim pgroup pgroup-opts? )*
    pgroup  ::= panel ( ('+'|',') panel )*
    pgroup-full ::= number* '.'? attrib ( '.' attrib )* ( ('+'|',') number* '.'? attrib ( '.' attrib )* )*
    panel   ::= number* '.'? attrib ( '.' attrib )*
    gallery-delim ::= '@'
    spread-delim  ::= ';'
    layout-delim  ::= '|'
    pgroup-delim  ::= '_'
    root-opts     ::= '{!' attrib* '}'
    gallery-opts  ::= '{@' attrib* '}'
    spread-opts   ::= '{;' attrib* '}'
    layout-opts   ::= '{|' attrib* '}'
    pgroup-opts   ::= '{_' attrib* '}'
    panel-opts    ::= '{+' attrib* '}'

    pc-levels-root-full
        ::= gallery gallery-opts? ( gallery-delim gallery gallery-opts? )* root-opts?
    gallery ::= spread  spread-opts? ( spread-delim spread spread-opts? )*
    spread  ::= layout  layout-opts? ( layout-delim layout layout-opts? )*
    layout  ::= pgroup  pgroup-opts? ( pgroup-delim pgroup pgroup-opts? )*
    pgroup  ::= panel ( ('+'|',') panel )*
    panel   ::= number* '.'? attrib ( '.' attrib )*
    gallery-delim ::= '@'
    spread-delim  ::= ';'
    layout-delim  ::= '|'
    pgroup-delim  ::= '_'
    root-opts     ::= '{!' attrib* '}'
    gallery-opts  ::= '{@' attrib* '}'
    spread-opts   ::= '{;' attrib* '}'
    layout-opts   ::= '{|' attrib* '}'
    pgroup-opts   ::= '{_' attrib* '}'
    panel-opts    ::= '{+' attrib* '}'

    pc-levels-root-concise
       ::= G  GO?  ( '@' G  GO?  )* RO?
    G  ::= S  SO?  ( ';' S  SO?  )*
    S  ::= L  LO?  ( '|'  L  LO? )*
    L  ::= PG PGO? ( '_' PG PGO? )*
    PG ::= P ( ('+'|',') P )*
    P  ::= number* '.'? att ( '.' att )*
    GD  ::= '@'
    SD  ::= ';'
    LD  ::= '|'
    PGD ::= '_'
    RO  ::= '{!' Attribute* '}'
    GO  ::= '{@' Attribute* '}'
    SO  ::= '{;' Attribute* '}'
    LO  ::= '{|' Attribute* '}'
    PGO ::= '{+' Attribute* '}'




*/